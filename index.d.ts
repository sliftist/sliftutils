// Auto-generated file. Do not edit manually.
// Generated by: yarn generate-index-dts

declare module "sliftutils/render-utils/DropdownCustom" {
    import preact from "preact";
    import { LengthOrPercentage } from "typesafecss/cssTypes";
    export declare class DropdownCustom<T> extends preact.Component<{
        class?: string;
        optionClass?: string;
        title?: string;
        value: T;
        onChange: (value: T, index: number) => void;
        maxWidth?: LengthOrPercentage;
        options: {
            value: T;
            label: (isOpen: boolean) => preact.ComponentChild;
        }[];
    }> {
        synced: {
            isOpen: boolean;
            tempIndexSelected: number | null;
        };
        onUnmount: (() => void)[];
        componentDidMount(): void;
        componentDidUnmount(): void;
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/FullscreenModal" {
    import preact from "preact";
    export declare function showFullscreenModal(contents: preact.ComponentChildren): void;
    export declare class FullscreenModal extends preact.Component<{
        parentState?: {
            open: boolean;
        };
        onCancel?: () => void;
        style?: preact.JSX.CSSProperties;
        outerStyle?: preact.JSX.CSSProperties;
    }> {
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/Input" {
    import preact from "preact";
    export type InputProps = (preact.JSX.HTMLAttributes<HTMLInputElement> & {
        /** ONLY throttles onChangeValue */
        throttle?: number;
        flavor?: "large" | "small" | "none";
        focusOnMount?: boolean;
        textarea?: boolean;
        /** Update on key stroke, not on blur (just does onInput = onChange, as onInput already does this) */
        hot?: boolean;
        /** Updates arrow keys with modifier behavior to use larger numbers, instead of decimals. */
        integer?: boolean;
        /** Only works with number/integer */
        reverseArrowKeyDirection?: boolean;
        inputRef?: (x: HTMLInputElement | null) => void;
        /** Don't blur on enter key */
        noEnterKeyBlur?: boolean;
        noFocusSelect?: boolean;
        inputKey?: string;
        fillWidth?: boolean;
        autocompleteValues?: string[];
        /** Forces the input to update when focused. Usually we hold updates, to prevent the user's
         *      typing to be interrupted by background updates.
         *      NOTE: "hot" is usually required when using this.
         */
        forceInputValueUpdatesWhenFocused?: boolean;
        onChangeValue?: (value: string) => void;
    });
    export declare class Input extends preact.Component<InputProps> {
        onFocusText: string;
        firstFocus: boolean;
        elem: HTMLInputElement | null;
        lastValue: unknown;
        lastChecked: unknown;
        onChangeThrottle: undefined | {
            throttle: number;
            run: (newValue: string) => void;
        };
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/InputLabel" {
    import preact from "preact";
    import { InputProps } from "./Input";
    import { URLParamStr } from "./URLParam";
    export type InputLabelProps = Omit<InputProps, "label" | "title"> & {
        label?: preact.ComponentChild;
        number?: boolean;
        /** A number, AND, an integer. Changes behavior arrow arrow keys as well */
        integer?: boolean;
        checkbox?: boolean;
        edit?: boolean;
        alwaysShowPencil?: boolean;
        outerClass?: string;
        maxDecimals?: number;
        percent?: boolean;
        editClass?: string;
        fontSize?: number;
        tooltip?: string;
        fillWidth?: boolean;
        useDateUI?: boolean;
    };
    export declare const startGuessDateRange: number;
    export declare const endGuessDateRange: number;
    export declare class InputLabel extends preact.Component<InputLabelProps> {
        synced: {
            editting: boolean;
            editInputValue: string;
            editUpdateSeqNum: number;
        };
        render(): preact.JSX.Element;
    }
    export declare class InputLabelURL extends preact.Component<InputLabelProps & {
        persisted: URLParamStr;
    }> {
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/InputPicker" {
    import preact from "preact";
    export type InputOption<T> = {
        value: T;
        label?: preact.ComponentChild;
        matchText?: string;
    };
    export type FullInputOption<T> = {
        value: T;
        label: preact.ComponentChild;
        matchText: string;
    };
    export declare class InputPickerURL extends preact.Component<{
        label?: preact.ComponentChild;
        options: (string | InputOption<string>)[];
        allowNonOptions?: boolean;
        value: {
            value: string;
        };
    }> {
        render(): preact.JSX.Element;
    }
    export declare class InputPicker<T> extends preact.Component<{
        label?: preact.ComponentChild;
        picked: T[];
        options: InputOption<T>[];
        addPicked: (value: T) => void;
        removePicked: (value: T) => void;
        allowNonOptions?: boolean;
    }> {
        synced: {
            pendingText: string;
            focused: boolean;
        };
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/LocalStorageParam" {
    export declare class LocalStorageParamStr {
        readonly storageKey: string;
        private defaultValue;
        private state;
        lastSetValue: string;
        constructor(storageKey: string, defaultValue?: string);
        forceUpdate(): void;
        get(): string;
        set(value: string): void;
        get value(): string;
        set value(value: string);
    }

}

declare module "sliftutils/render-utils/SyncedController" {
    import { SocketRegistered } from "socket-function/SocketFunctionTypes";
    type RemapFunction<T> = T extends (...args: infer Args) => Promise<infer Return> ? {
        (...args: Args): Return | undefined;
        promise(...args: Args): Promise<Return>;
        refresh(...args: Args): void;
        refreshAll(): void;
        reset(...args: Args): void;
        resetAll(): void;
        isLoading(...args: Args): boolean;
        setCache(cache: {
            args: Args;
            result: Return;
        }): void;
    } : T;
    export declare function getSyncedController<T extends SocketRegistered>(controller: T, config?: {
        /** When a controller call for a write finishes, we refresh all readers.
         *      - Invalidation is global, across all controllers.
         */
        reads?: {
            [key in keyof T["nodes"][""]]?: string[];
        };
        writes?: {
            [key in keyof T["nodes"][""]]?: string[];
        };
    }): {
        (nodeId: string): {
            [fnc in keyof T["nodes"][""]]: RemapFunction<T["nodes"][""][fnc]>;
        } & {
            resetAll(): void;
            refreshAll(): void;
            anyPending(): boolean;
        };
        resetAll(): void;
        refreshAll(): void;
        anyPending(): boolean;
        rerenderAll(): void;
    };
    export {};

}

declare module "sliftutils/render-utils/SyncedLoadingIndicator" {
    import * as preact from "preact";
    export declare class SyncedLoadingIndicator extends preact.Component<{
        controller: {
            anyPending: () => boolean;
        };
    }> {
        render(): preact.JSX.Element | null;
    }

}

declare module "sliftutils/render-utils/Table" {
    import preact from "preact";
    import { JSXFormatter } from "./GenericFormat";
    export type ColumnType<T = unknown, Row extends RowType = RowType> = undefined | null | {
        center?: boolean;
        title?: preact.ComponentChild;
        formatter?: JSXFormatter<T, Row>;
    };
    export type RowType = {
        [columnName: string]: unknown;
    };
    export type ColumnsType = {
        [columnName: string]: ColumnType;
    };
    export type TableType<RowT extends RowType = RowType> = {
        columns: {
            [columnName in keyof RowT]?: ColumnType<RowT[columnName], RowT>;
        };
        rows: RowT[];
    };
    export declare class Table<RowT extends RowType> extends preact.Component<TableType<RowT> & {
        class?: string;
        cellClass?: string;
        initialLimit?: number;
        lineLimit?: number;
        characterLimit?: number;
        excludeEmptyColumns?: boolean;
    }> {
        state: {
            limit: number;
        };
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/URLParam" {
    export declare class URLParamStr {
        readonly urlKey: string;
        private state;
        lastSetValue: string;
        constructor(urlKey: string);
        forceUpdate(): void;
        get(): string;
        set(value: string): void;
        get value(): string;
        set value(value: string);
    }
    export declare function batchUrlUpdate<T>(code: () => T): T;
    export declare function createLink(params: [URLParamStr, string][]): string;

}

declare module "sliftutils/render-utils/asyncObservable" {
    export declare function asyncCache<Args, T>(getValue: (args: Args) => Promise<T>): {
        (args: Args): T | undefined;
    };

}

declare module "sliftutils/render-utils/mobxTyped" {
    export declare function configureMobxNextFrameScheduler(): void;

}

declare module "sliftutils/render-utils/modal" {
    import preact from "preact";
    export declare function showModal(config: {
        contents: preact.ComponentChildren;
    }): {
        close: () => void;
    };

}

declare module "sliftutils/render-utils/observer" {
    import * as preact from "preact";
    import { Reaction } from "mobx";
    export declare function observer<T extends {
        new (...args: any[]): {
            render(): preact.ComponentChild;
            forceUpdate(callback?: () => void): void;
            componentWillUnmount?(): void;
        };
    }>(Constructor: T): {
        new (...args: any[]): {
            reaction: Reaction;
            componentWillUnmount(): void;
            render(...args: any[]): preact.ComponentChild;
            forceUpdate(callback?: () => void): void;
        };
        readonly name: string;
    } & T;

}
