// Auto-generated file. Do not edit manually.
// Generated by: yarn generate-index-dts

declare module "sliftutils/misc/apiKeys" {
    import preact from "preact";
    export declare class APIKeysControl extends preact.Component {
        render(): preact.JSX.Element;
    }
    export declare const getAPIKey: {
        (key: string): Promise<string>;
        clear(key: string): void;
        clearAll(): void;
        forceSet(key: string, value: Promise<string>): void;
        getAllKeys(): string[];
        get(key: string): Promise<string> | undefined;
    };
    export declare class ManageAPIKeys extends preact.Component {
        render(): string;
    }

}

declare module "sliftutils/misc/cborx" {
    /// <reference types="node" />
    /// <reference types="node" />
    export declare function cborEncode<T>(value: T): Buffer;
    export declare function cborDecode<T>(buffer: Buffer): T;

}

declare module "sliftutils/misc/environment" {
    export declare function isInChromeExtension(): string | false;
    export declare function isInChromeExtensionBackground(): boolean;
    export declare function isInChromeExtensionContentScript(): boolean | "";
    export declare function isInElectron(): string | false | undefined;
    export declare function triggerIsInBuild(): void;
    export declare function isInBuild(): boolean;
    export declare function isInBrowser(): boolean;

}

declare module "sliftutils/misc/fs" {
    export declare function getAllFiles(folder: string): AsyncIterableIterator<string>;

}

declare module "sliftutils/misc/getSecret" {
    export declare function resetSecret(key: string): void;
    export declare const getSecret: {
        (key: string): Promise<string>;
        clear(key: string): void;
        clearAll(): void;
        forceSet(key: string, value: Promise<string>): void;
        getAllKeys(): string[];
        get(key: string): Promise<string> | undefined;
    };

}

declare module "sliftutils/misc/helpers" {
    export declare function waitForDiskCollectionFlush(): Promise<void>;

}

declare module "sliftutils/misc/matchFilter" {
    export declare function matchFilter(filter: {
        value: string;
    }, value: string): boolean;

}

declare module "sliftutils/misc/openrouter" {
    export type MessageHistory = {
        role: "system" | "user" | "assistant";
        content: string;
    }[];
    export type MessageHistory2 = {
        role: "system" | "user" | "assistant";
        content: string | {
            type: "image_url";
            image_url: {
                url: string;
            };
        }[];
    }[];
    export declare function getTotalCost(): number;
    type OpenRouterOptions = {
        provider?: {
            sort?: "throughput" | "price" | "latency";
            order?: string[];
        };
        reasoningEffort?: "low" | "medium" | "high";
    };
    /** IMPORTANT! Make sure to tell the AI to return yaml. */
    export declare function yamlOpenRouterCall<T>(config: {
        model: string;
        messages: MessageHistory;
        retries?: number;
        options?: OpenRouterOptions;
        onCost?: (cost: number) => void;
        validate?: (response: T) => void;
    }): Promise<T>;
    export declare function openRouterCall(config: {
        model: string;
        messages: MessageHistory;
        options?: OpenRouterOptions;
        onCost?: (cost: number) => void;
        retries?: number;
    }): Promise<string>;
    export declare function openRouterCallBase(config: {
        model: string;
        messages: MessageHistory2;
        options?: OpenRouterOptions;
        onCost?: (cost: number) => void;
        retries?: number;
    }): Promise<string>;
    export {};

}

declare module "sliftutils/misc/random" {
    export declare function getSeededRandom(seed: number): () => number;
    export declare function shuffle<T>(array: T[], seed: number): T[];
    export declare function secureRandom(): number;

}

declare module "sliftutils/misc/types" {
    export declare function isDefined<T>(value: T | undefined | null): value is T;

}

declare module "sliftutils/misc/yaml" {
    export declare function parseYAML(text: string): unknown;
    export declare function stringifyYAML(value: unknown): string;

}

declare module "sliftutils/misc/yamlBase" {
    export declare const parse: (input: string) => unknown;
    export declare const stringify: (input: unknown) => string;

}

declare module "sliftutils/misc/zip" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { MaybePromise } from "socket-function/src/types";
    export declare class Zip {
        static gzip(buffer: Buffer, level?: number): Promise<Buffer>;
        static gunzip(buffer: Buffer): MaybePromise<Buffer>;
        static gunzipAsyncBase(buffer: Buffer): Promise<Buffer>;
        static gunzipUntracked(buffer: Buffer): Promise<Buffer>;
        static gunzipSync(buffer: Buffer): Buffer;
        private static gunzipUntrackedSync;
        static gunzipBatch(buffers: Buffer[]): Promise<Buffer[]>;
    }

}

declare module "sliftutils/render-utils/Anchor" {
    import preact from "preact";
    import { URLParam } from "./URLParam";
    export declare class Anchor extends preact.Component<{
        className?: string;
        params: ([URLParam, unknown] | [string, string])[];
        button?: boolean;
    } & Omit<preact.JSX.HTMLAttributes<HTMLAnchorElement>, "href">> {
        render(): preact.JSX.Element;
    }
    export declare function createLinkRaw(params: ([URLParam, unknown])[]): string;

}

declare module "sliftutils/render-utils/DropdownCustom" {
    import preact from "preact";
    import { LengthOrPercentage } from "typesafecss/cssTypes";
    export declare class DropdownCustom<T> extends preact.Component<{
        class?: string;
        optionClass?: string;
        title?: string;
        value: T;
        onChange: (value: T, index: number) => void;
        maxWidth?: LengthOrPercentage;
        options: {
            value: T;
            label: (isOpen: boolean) => preact.ComponentChild;
        }[];
    }> {
        synced: {
            isOpen: boolean;
            tempIndexSelected: number | null;
        };
        onUnmount: (() => void)[];
        componentDidMount(): void;
        componentDidUnmount(): void;
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/FullscreenModal" {
    import preact from "preact";
    export declare function showFullscreenModal(config: {
        contents: preact.ComponentChildren;
        onClose?: () => void;
    }): void;
    export declare class FullscreenModal extends preact.Component<{
        parentState?: {
            open: boolean;
        };
        onCancel?: () => void;
        style?: preact.JSX.CSSProperties;
        outerStyle?: preact.JSX.CSSProperties;
    }> {
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/GenericFormat" {
    import preact from "preact";
    export declare const errorMessage: string;
    export declare const warnMessage: string;
    export type RowType = {
        [columnName: string]: unknown;
    };
    export type FormatContext<RowT extends RowType = RowType> = {
        row?: RowT;
        columnName?: RowT extends undefined ? string : keyof RowT;
    };
    export type JSXFormatter<T = unknown, RowT extends RowType = RowType> = (StringFormatters | `varray:${StringFormatters}` | `link:${string}` | ((value: T, context?: FormatContext<RowT>) => preact.ComponentChild));
    type StringFormatters = ("guess" | "string" | "number" | "timeSpan" | "date" | "error" | "link" | "toSpaceCase");
    export declare function toSpaceCase(text: string): string;
    export declare function formatValue(value: unknown, formatter?: JSXFormatter, context?: FormatContext): preact.ComponentChild;
    export {};

}

declare module "sliftutils/render-utils/Input" {
    import preact from "preact";
    export type InputProps = (preact.JSX.HTMLAttributes<HTMLInputElement> & {
        /** ONLY throttles onChangeValue */
        throttle?: number;
        flavor?: "large" | "small" | "none";
        focusOnMount?: boolean;
        textarea?: boolean;
        /** Update on key stroke, not on blur (just does onInput = onChange, as onInput already does this) */
        hot?: boolean;
        /** Updates arrow keys with modifier behavior to use larger numbers, instead of decimals. */
        integer?: boolean;
        /** Only works with number/integer */
        reverseArrowKeyDirection?: boolean;
        inputRef?: (x: HTMLInputElement | null) => void;
        /** Don't blur on enter key */
        noEnterKeyBlur?: boolean;
        noFocusSelect?: boolean;
        inputKey?: string;
        fillWidth?: boolean;
        autocompleteValues?: string[];
        /** Forces the input to update when focused. Usually we hold updates, to prevent the user's
         *      typing to be interrupted by background updates.
         *      NOTE: "hot" is usually required when using this.
         */
        forceInputValueUpdatesWhenFocused?: boolean;
        onChangeValue?: (value: string) => void;
    });
    export declare class Input extends preact.Component<InputProps> {
        onFocusText: string;
        firstFocus: boolean;
        elem: HTMLInputElement | null;
        lastValue: unknown;
        lastChecked: unknown;
        onChangeThrottle: undefined | {
            throttle: number;
            run: (newValue: string) => void;
        };
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/InputLabel" {
    import preact from "preact";
    type InputProps = (preact.JSX.HTMLAttributes<HTMLInputElement> & {
        /** ONLY throttles onChangeValue */
        throttle?: number;
        flavor?: "large" | "small" | "none";
        focusOnMount?: boolean;
        textarea?: boolean;
        /** Update on key stroke, not on blur (just does onInput = onChange, as onInput already does this) */
        hot?: boolean;
        /** Updates arrow keys with modifier behavior to use larger numbers, instead of decimals. */
        integer?: boolean;
        /** Only works with number/integer */
        reverseArrowKeyDirection?: boolean;
        inputRef?: (x: HTMLInputElement | null) => void;
        /** Don't blur on enter key */
        noEnterKeyBlur?: boolean;
        noFocusSelect?: boolean;
        inputKey?: string;
        fillWidth?: boolean;
        autocompleteValues?: string[];
        /** Forces the input to update when focused. Usually we hold updates, to prevent the user's
         *      typing to be interrupted by background updates.
         *      NOTE: "hot" is usually required when using this.
         */
        forceInputValueUpdatesWhenFocused?: boolean;
        onChangeValue?: (value: string) => void;
    });
    export type InputLabelProps = Omit<InputProps, "label" | "title"> & {
        label?: preact.ComponentChild;
        number?: boolean;
        /** A number, AND, an integer. Changes behavior arrow arrow keys as well */
        integer?: boolean;
        checkbox?: boolean;
        edit?: boolean;
        alwaysShowPencil?: boolean;
        outerClass?: string;
        maxDecimals?: number;
        percent?: boolean;
        editClass?: string;
        fontSize?: number;
        tooltip?: string;
        fillWidth?: boolean;
        useDateUI?: boolean;
    };
    export declare const startGuessDateRange: number;
    export declare const endGuessDateRange: number;
    export declare class InputLabel extends preact.Component<InputLabelProps> {
        synced: {
            editting: boolean;
            editInputValue: string;
            editUpdateSeqNum: number;
        };
        render(): preact.JSX.Element;
    }
    export declare class InputLabelURL extends preact.Component<InputLabelProps & {
        persisted: {
            value: unknown;
        };
    }> {
        render(): preact.JSX.Element;
    }
    export {};

}

declare module "sliftutils/render-utils/InputPicker" {
    import preact from "preact";
    export type InputOption<T> = {
        value: T;
        label?: preact.ComponentChild;
        matchText?: string;
    };
    export type FullInputOption<T> = {
        value: T;
        label: preact.ComponentChild;
        matchText: string;
    };
    export declare class InputPickerURL extends preact.Component<{
        label?: preact.ComponentChild;
        options: (string | InputOption<string>)[];
        allowNonOptions?: boolean;
        value: {
            value: string;
        };
    }> {
        render(): preact.JSX.Element;
    }
    export declare class InputPicker<T> extends preact.Component<{
        label?: preact.ComponentChild;
        picked: T[];
        options: InputOption<T>[];
        addPicked: (value: T) => void;
        removePicked: (value: T) => void;
        allowNonOptions?: boolean;
    }> {
        synced: {
            pendingText: string;
            focused: boolean;
        };
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/LocalStorageParam" {
    export declare class LocalStorageParamStr {
        readonly storageKey: string;
        private defaultValue;
        private state;
        lastSetValue: string;
        constructor(storageKey: string, defaultValue?: string);
        forceUpdate(): void;
        get(): string;
        set(value: string): void;
        get value(): string;
        set value(value: string);
    }

}

declare module "sliftutils/render-utils/SyncedController" {
    import { SocketRegistered } from "socket-function/SocketFunctionTypes";
    type RemapFunction<T> = T extends (...args: infer Args) => Promise<infer Return> ? {
        (...args: Args): Return | undefined;
        promise(...args: Args): Promise<Return>;
        refresh(...args: Args): void;
        refreshAll(): void;
        reset(...args: Args): void;
        resetAll(): void;
        isLoading(...args: Args): boolean;
        setCache(cache: {
            args: Args;
            result: Return;
        }): void;
    } : T;
    export declare function getSyncedController<T extends SocketRegistered>(controller: T, config?: {
        /** When a controller call for a write finishes, we refresh all readers.
         *      - Invalidation is global, across all controllers.
         */
        reads?: {
            [key in keyof T["nodes"][""]]?: string[];
        };
        writes?: {
            [key in keyof T["nodes"][""]]?: string[];
        };
    }): {
        (nodeId: string): {
            [fnc in keyof T["nodes"][""]]: RemapFunction<T["nodes"][""][fnc]>;
        } & {
            resetAll(): void;
            refreshAll(): void;
            anyPending(): boolean;
        };
        resetAll(): void;
        refreshAll(): void;
        anyPending(): boolean;
        rerenderAll(): void;
    };
    export {};

}

declare module "sliftutils/render-utils/SyncedLoadingIndicator" {
    import * as preact from "preact";
    export declare class SyncedLoadingIndicator extends preact.Component<{
        controller: {
            anyPending: () => boolean;
        };
    }> {
        render(): preact.JSX.Element | null;
    }

}

declare module "sliftutils/render-utils/Table" {
    import preact from "preact";
    import { JSXFormatter } from "./GenericFormat";
    export type ColumnType<T = unknown, Row extends RowType = RowType> = undefined | null | {
        center?: boolean;
        title?: preact.ComponentChild;
        formatter?: JSXFormatter<T, Row>;
    };
    export type RowType = {
        [columnName: string]: unknown;
    };
    export type ColumnsType = {
        [columnName: string]: ColumnType;
    };
    export type TableType<RowT extends RowType = RowType> = {
        columns: {
            [columnName in keyof RowT]?: ColumnType<RowT[columnName], RowT>;
        };
        rows: RowT[];
    };
    export declare class Table<RowT extends RowType> extends preact.Component<TableType<RowT> & {
        class?: string;
        cellClass?: string;
        initialLimit?: number;
        lineLimit?: number;
        characterLimit?: number;
        excludeEmptyColumns?: boolean;
        getRowFields?: (row: RowT) => preact.JSX.HTMLAttributes<HTMLTableRowElement>;
    }> {
        state: {
            limit: number;
        };
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/render-utils/URLParam" {
    export declare class URLParam<T = unknown> {
        readonly key: string;
        private defaultValue;
        constructor(key: string, defaultValue?: T);
        valueSeqNum: {
            value: number;
        };
        get(): T;
        set(value: T): void;
        reset(): void;
        getOverride(value: T): [string, string];
        get value(): T;
        set value(value: T);
    }
    export declare function getResolvedParam(param: [URLParam, unknown] | [string, string]): [string, string];
    export declare function batchURLParamUpdate(params: ([URLParam, unknown] | [string, string])[]): void;
    export declare function getCurrentUrl(): string;

}

declare module "sliftutils/render-utils/asyncObservable" {
    export declare function asyncCache<Args, T>(getValue: (args: Args) => Promise<T>): {
        (args: Args): T | undefined;
    };

}

declare module "sliftutils/render-utils/colors" {
    export declare const redButton: string;
    export declare const yellowButton: string;
    export declare const greenButton: string;
    export declare const errorMessage: string;
    export declare const warnMessage: string;
    export declare const AnchorClass: string;

}

declare module "sliftutils/render-utils/mobxTyped" {
    export declare function configureMobxNextFrameScheduler(): void;

}

declare module "sliftutils/render-utils/modal" {
    import preact from "preact";
    export declare function showModal(config: {
        contents: preact.ComponentChildren;
        onClose?: () => void;
    }): {
        close: () => void;
    };
    export declare function closeAllModals(): void;

}

declare module "sliftutils/render-utils/niceStringify" {
    export declare const niceStringifyTrue = "";
    export declare const niceStringifyNan = "{NaN}";
    export declare const niceStringifyUndefined = "{Undefined}";
    export declare function niceStringify(value: unknown): string;
    export declare function niceParse(str: string | undefined, noSpecialTrue?: boolean): unknown;

}

declare module "sliftutils/render-utils/observer" {
    import * as preact from "preact";
    import { Reaction } from "mobx";
    export declare function observer<T extends {
        new (...args: any[]): {
            render(): preact.ComponentChild;
            forceUpdate(callback?: () => void): void;
            componentWillUnmount?(): void;
        };
    }>(Constructor: T): {
        new (...args: any[]): {
            reaction: Reaction;
            componentWillUnmount(): void;
            render(...args: any[]): preact.ComponentChild;
            forceUpdate(callback?: () => void): void;
        };
        readonly name: string;
    } & T;

}

declare module "sliftutils/storage/CBORStorage" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { IStorage } from "./IStorage";
    export declare class CBORStorage<T> implements IStorage<T> {
        private storage;
        constructor(storage: IStorage<Buffer>);
        get(key: string): Promise<T | undefined>;
        set(key: string, value: T): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        watchResync(callback: () => void): void;
        reset(): Promise<void>;
    }

}

declare module "sliftutils/storage/CachedStorage" {
    import { StorageSync } from "./StorageObservable";
    export declare function newCachedStrStorage<T>(folder: string, getValue: (key: string) => Promise<T>): StorageSync<T>;

}

declare module "sliftutils/storage/DelayedStorage" {
    import { IStorage } from "./IStorage";
    export declare class DelayedStorage<T> implements IStorage<T> {
        private storage;
        constructor(storage: Promise<IStorage<T>>);
        get(key: string): Promise<T | undefined>;
        set(key: string, value: T): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        reset(): Promise<void>;
        watchResync(callback: () => void): void;
    }

}

declare module "sliftutils/storage/DiskCollection" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { IStorage, IStorageSync } from "./IStorage";
    import { StorageSync } from "./StorageObservable";
    import { TransactionStorage } from "./TransactionStorage";
    export declare class DiskCollection<T> implements IStorageSync<T> {
        private collectionName;
        private config?;
        constructor(collectionName: string, config?: {
            writeDelay?: number | undefined;
            cbor?: boolean | undefined;
            noPrompt?: boolean | undefined;
        } | undefined);
        transactionStorage: TransactionStorage | undefined;
        initStorage(): Promise<IStorage<T>>;
        baseStorage: Promise<IStorage<T>>;
        private synced;
        get(key: string): T | undefined;
        getPromise(key: string): Promise<T | undefined>;
        set(key: string, value: T): void;
        remove(key: string): void;
        getKeys(): string[];
        getKeysPromise(): Promise<string[]>;
        getEntries(): [string, T][];
        getValues(): T[];
        getValuesPromise(): Promise<T[]>;
        getInfo(key: string): {
            size: number;
            lastModified: number;
        } | undefined;
        reset(): Promise<void>;
    }
    export declare class DiskCollectionPromise<T> implements IStorage<T> {
        private collectionName;
        private writeDelay?;
        constructor(collectionName: string, writeDelay?: number | undefined);
        initStorage(): Promise<IStorage<T>>;
        private synced;
        get(key: string): Promise<T | undefined>;
        set(key: string, value: T): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        reset(): Promise<void>;
    }
    export declare class DiskCollectionRaw implements IStorage<Buffer> {
        private collectionName;
        constructor(collectionName: string);
        initStorage(): Promise<IStorage<Buffer>>;
        private synced;
        get(key: string): Promise<Buffer | undefined>;
        set(key: string, value: Buffer): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        reset(): Promise<void>;
    }
    export declare class DiskCollectionRawBrowser {
        private collectionName;
        constructor(collectionName: string);
        initStorage(): Promise<IStorage<Buffer>>;
        private synced;
        get(key: string): Buffer | undefined;
        getPromise(key: string): Promise<Buffer | undefined>;
        set(key: string, value: Buffer): void;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        reset(): Promise<void>;
    }
    export declare function newFileStorageBufferSyncer(folder?: string): StorageSync<Buffer>;
    export declare function newFileStorageJSONSyncer<T>(folder?: string): StorageSync<T>;

}

declare module "sliftutils/storage/FileFolderAPI" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { IStorageRaw } from "./IStorage";
    declare global {
        interface Window {
            showSaveFilePicker(config?: {
                types: {
                    description: string;
                    accept: {
                        [mimeType: string]: string[];
                    };
                }[];
            }): Promise<FileSystemFileHandle>;
            showDirectoryPicker(): Promise<FileSystemDirectoryHandle>;
            showOpenFilePicker(config?: {
                types: {
                    description: string;
                    accept: {
                        [mimeType: string]: string[];
                    };
                }[];
            }): Promise<FileSystemFileHandle[]>;
        }
        interface FileSystemDirectoryHandle {
            requestPermission(config?: {
                mode: "read" | "readwrite";
            }): Promise<PermissionState>;
        }
    }
    type FileWrapper = {
        getFile(): Promise<{
            size: number;
            lastModified: number;
            arrayBuffer(): Promise<ArrayBuffer>;
        }>;
        createWritable(config?: {
            keepExistingData?: boolean;
        }): Promise<{
            seek(offset: number): Promise<void>;
            write(value: Buffer): Promise<void>;
            close(): Promise<void>;
        }>;
    };
    type DirectoryWrapper = {
        removeEntry(key: string, options?: {
            recursive?: boolean;
        }): Promise<void>;
        getFileHandle(key: string, options?: {
            create?: boolean;
        }): Promise<FileWrapper>;
        getDirectoryHandle(key: string, options?: {
            create?: boolean;
        }): Promise<DirectoryWrapper>;
        [Symbol.asyncIterator](): AsyncIterableIterator<[
            string,
            {
                kind: "file";
                name: string;
                getFile(): Promise<FileWrapper>;
            } | {
                kind: "directory";
                name: string;
                getDirectoryHandle(key: string, options?: {
                    create?: boolean;
                }): Promise<DirectoryWrapper>;
            }
        ]>;
    };
    export declare function setFileAPIKey(key: string): void;
    export declare const getDirectoryHandle: {
        (): Promise<DirectoryWrapper>;
        reset(): void;
        set(newValue: Promise<DirectoryWrapper>): void;
    };
    export declare const getFileStorageNested: {
        (key: string): Promise<FileStorage>;
        clear(key: string): void;
        clearAll(): void;
        forceSet(key: string, value: Promise<FileStorage>): void;
        getAllKeys(): string[];
        get(key: string): Promise<FileStorage> | undefined;
    };
    export declare const getFileStorage: {
        (): Promise<FileStorage>;
        reset(): void;
        set(newValue: Promise<FileStorage>): void;
    };
    export declare function resetStorageLocation(): void;
    export type NestedFileStorage = {
        hasKey(key: string): Promise<boolean>;
        getStorage(key: string): Promise<FileStorage>;
        removeStorage(key: string): Promise<void>;
        getKeys(includeFolders?: boolean): Promise<string[]>;
    };
    export type FileStorage = IStorageRaw & {
        folder: NestedFileStorage;
    };
    export {};

}

declare module "sliftutils/storage/IStorage" {
    /// <reference types="node" />
    /// <reference types="node" />
    export type IStorageSync<T> = {
        get(key: string): T | undefined;
        set(key: string, value: T): void;
        remove(key: string): void;
        getKeys(): string[];
        getValues(): T[];
        getEntries(): [string, T][];
        getInfo(key: string): {
            size: number;
            lastModified: number;
        } | undefined;
        reset(): Promise<void>;
    };
    export type IStorage<T> = {
        get(key: string): Promise<T | undefined>;
        set(key: string, value: T): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<undefined | {
            size: number;
            lastModified: number;
        }>;
        reset(): Promise<void>;
        watchResync?: (callback: () => void) => void;
    };
    export type IStorageRaw = {
        get(key: string): Promise<Buffer | undefined>;
        append(key: string, value: Buffer): Promise<void>;
        set(key: string, value: Buffer): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(includeFolders?: boolean): Promise<string[]>;
        getInfo(key: string): Promise<undefined | {
            size: number;
            lastModified: number;
        }>;
        reset(): Promise<void>;
    };

}

declare module "sliftutils/storage/IndexedDBFileFolderAPI" {
    import { FileStorage } from "./FileFolderAPI";
    export declare const getFileStorageIndexDB: {
        (): Promise<FileStorage>;
        reset(): void;
        set(newValue: Promise<FileStorage>): void;
    };

}

declare module "sliftutils/storage/JSONStorage" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { IStorage } from "./IStorage";
    export declare class JSONStorage<T> implements IStorage<T> {
        private storage;
        constructor(storage: IStorage<Buffer>);
        get(key: string): Promise<T | undefined>;
        set(key: string, value: T): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        watchResync(callback: () => void): void;
        reset(): Promise<void>;
    }

}

declare module "sliftutils/storage/PendingManager" {
    import preact from "preact";
    export declare function setPending(group: string, message: string): void;
    export declare function hasPending(): boolean;
    export declare class PendingDisplay extends preact.Component {
        render(): preact.JSX.Element;
    }

}

declare module "sliftutils/storage/PendingStorage" {
    import { IStorage } from "./IStorage";
    export declare class PendingStorage<T> implements IStorage<T> {
        private pendingGroup;
        private storage;
        pending: Map<string, number>;
        constructor(pendingGroup: string, storage: IStorage<T>);
        get(key: string): Promise<T | undefined>;
        set(key: string, value: T): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        private watchPending;
        private updatePending;
        reset(): Promise<void>;
        watchResync(callback: () => void): void;
    }

}

declare module "sliftutils/storage/PrivateFileSystemStorage" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { IStorageRaw } from "./IStorage";
    export declare class PrivateFileSystemStorage implements IStorageRaw {
        private path;
        private rootHandle;
        constructor(path: string);
        private ensureInitialized;
        private directoryExists;
        private getDirectoryHandle;
        private getFileHandle;
        private fileExists;
        get(key: string): Promise<Buffer | undefined>;
        set(key: string, value: Buffer): Promise<void>;
        append(key: string, value: Buffer): Promise<void>;
        remove(key: string): Promise<void>;
        getKeys(): Promise<string[]>;
        getInfo(key: string): Promise<undefined | {
            size: number;
            lastModified: number;
        }>;
        reset(): Promise<void>;
    }

}

declare module "sliftutils/storage/StorageObservable" {
    import { IStorage, IStorageSync } from "./IStorage";
    export declare class StorageSync<T> implements IStorageSync<T> {
        storage: IStorage<T>;
        cached: import("mobx").ObservableMap<string, T | undefined>;
        infoCached: import("mobx").ObservableMap<string, {
            size: number;
            lastModified: number;
        } | undefined>;
        keys: Set<string>;
        synced: {
            keySeqNum: number;
        };
        constructor(storage: IStorage<T>);
        get(key: string): T | undefined;
        set(key: string, value: T): void;
        remove(key: string): void;
        private loadedKeys;
        getKeys(): string[];
        getInfo(key: string): {
            size: number;
            lastModified: number;
        } | undefined;
        getValues(): T[];
        getEntries(): [string, T][];
        getPromise(key: string): Promise<T | undefined>;
        private pendingGetKeys;
        getKeysPromise(): Promise<string[]>;
        reload(): void;
        reloadKeys(): void;
        reloadKey(key: string): void;
        reset(): Promise<void>;
    }

}

declare module "sliftutils/storage/TransactionStorage" {
    /// <reference types="node" />
    /// <reference types="node" />
    import { IStorage, IStorageRaw } from "./IStorage";
    interface TransactionEntry {
        key: string;
        value: Buffer | undefined;
        isZipped: boolean;
        time: number;
    }
    export declare class TransactionStorage implements IStorage<Buffer> {
        private rawStorage;
        private debugName;
        private writeDelay;
        cache: Map<string, TransactionEntry>;
        private diskFiles;
        private currentChunk;
        private entryCount;
        private static allStorage;
        constructor(rawStorage: IStorageRaw, debugName: string, writeDelay?: number);
        static compressAll(): Promise<void>;
        private resyncCallbacks;
        watchResync(callback: () => void): void;
        private init;
        private getCurrentChunk;
        private updateDiskFileTimestamp;
        private onAddToChunk;
        get(key: string): Promise<Buffer | undefined>;
        set(key: string, value: Buffer): Promise<void>;
        remove(key: string): Promise<void>;
        getInfo(key: string): Promise<{
            size: number;
            lastModified: number;
        } | undefined>;
        private pendingAppends;
        private extraAppends;
        private pendingWrite;
        pushAppend(entry: TransactionEntry): Promise<void>;
        private updatePendingAppends;
        getKeys(): Promise<string[]>;
        checkDisk(): Promise<void>;
        private loadAllTransactions;
        private parseTransactionFile;
        private applyTransactionEntries;
        private readTransactionEntry;
        private serializeTransactionEntry;
        private getHeader;
        private chunkBuffers;
        private compressing;
        private compressTransactionLog;
        reset(): Promise<void>;
    }
    export {};

}

declare module "sliftutils/storage/fileSystemPointer" {
    export type FileSystemPointer = string;
    export declare function storeFileSystemPointer(config: {
        mode: "read" | "readwrite";
        handle: FileSystemFileHandle | FileSystemDirectoryHandle;
    }): Promise<FileSystemPointer>;
    export declare function deleteFileSystemPointer(pointer: FileSystemPointer): Promise<void>;
    export declare function getFileSystemPointer(config: {
        pointer: FileSystemPointer;
    }): Promise<{
        onUserActivation(modeOverride?: "read" | "readwrite"): Promise<FileSystemFileHandle | FileSystemDirectoryHandle>;
    } | undefined>;

}

declare module "sliftutils/storage/storage" {


    declare module "node-forge" {
        declare type Ed25519PublicKey = {
            publicKeyBytes: Buffer;
        } & Buffer;
        declare type Ed25519PrivateKey = {
            privateKeyBytes: Buffer;
        } & Buffer;
        class ed25519 {
            static generateKeyPair(): { publicKey: Ed25519PublicKey, privateKey: Ed25519PrivateKey };
            static privateKeyToPem(key: Ed25519PrivateKey): string;
            static privateKeyFromPem(pem: string): Ed25519PrivateKey;
            static publicKeyToPem(key: Ed25519PublicKey): string;
            static publicKeyFromPem(pem: string): Ed25519PublicKey;
        }
    }


    interface FileSystemDirectoryHandle {
        [Symbol.asyncIterator](): AsyncIterator<[string, FileSystemFileHandle | FileSystemDirectoryHandle]>;
        requestPermission(config: { mode: "read" | "readwrite" }): Promise<void>;
    }
    interface FileSystemFileHandle {
        getFile(): File;
        createWritable(): FileSystemWritableFileStream;
    }

    interface Window {
        showSaveFilePicker(config?: {
            types: {
                description: string; accept: { [mimeType: string]: string[] }
            }[];
        }): Promise<FileSystemFileHandle>;
        showDirectoryPicker(): Promise<FileSystemDirectoryHandle>;
        showOpenFilePicker(config?: {
            types: {
                description: string; accept: { [mimeType: string]: string[] }
            }[];
        }): Promise<FileSystemFileHandle[]>;
    }
}
